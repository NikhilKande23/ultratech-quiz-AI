<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UltraTech GENIUS BATTLE - Admin Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            min-height: 100vh;
            color: white;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255,255,255,0.1);
            padding: 30px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
        }

        .header h1 {
            font-size: 3rem;
            background: linear-gradient(45deg, #f1c40f, #fff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .round-control {
            background: rgba(255,255,255,0.1);
            padding: 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 2px solid transparent;
            text-align: center;
            min-width: 200px;
        }

        .round-control.active {
            border-color: #f1c40f;
            background: rgba(241,196,15,0.2);
        }

        .round-title {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #f1c40f;
        }

        .control-btn {
            background: linear-gradient(45deg, #3498db, #2980b9);
            border: none;
            padding: 12px 25px;
            border-radius: 20px;
            color: white;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .control-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .control-btn.start {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
        }

        .control-btn.stop {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .control-btn.reset {
            background: linear-gradient(45deg, #f39c12, #e67e22);
        }

        .control-btn.danger {
            background: linear-gradient(45deg, #8e44ad, #9b59b6);
            font-size: 1.1rem;
            padding: 15px 30px;
            animation: pulseGlow 2s infinite;
        }

        @keyframes pulseGlow {
            0%, 100% { box-shadow: 0 0 5px rgba(142,68,173,0.5); }
            50% { box-shadow: 0 0 20px rgba(142,68,173,0.8); }
        }

        .control-btn:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
            transform: none;
        }

        .game-reset-section {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(142,68,173,0.15);
            border-radius: 15px;
            border: 2px solid #8e44ad;
        }

        .game-reset-section h3 {
            color: #8e44ad;
            margin-bottom: 15px;
            font-size: 1.4rem;
        }

        .warning-text {
            color: #e74c3c;
            font-size: 0.9rem;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .stats-overview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255,255,255,0.1);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .stat-number {
            font-size: 2.5rem;
            font-weight: bold;
            color: #f1c40f;
            margin-bottom: 10px;
        }

        .stat-label {
            font-size: 1.1rem;
            opacity: 0.8;
        }

        .rounds-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .round-section {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(15px);
        }

        .round-section h2 {
            color: #f1c40f;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.8rem;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            margin: 8px 0;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .leaderboard-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .rank {
            font-size: 1.2rem;
            font-weight: bold;
            width: 30px;
            text-align: center;
        }

        .rank.first { color: #f1c40f; }
        .rank.second { color: #bdc3c7; }
        .rank.third { color: #cd7f32; }

        .team-info {
            flex: 1;
            margin-left: 15px;
        }

        .team-name {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .team-details {
            font-size: 0.9rem;
            opacity: 0.7;
            margin-top: 2px;
        }

        .score {
            font-size: 1.5rem;
            font-weight: bold;
            color: #f1c40f;
        }

        .teams-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .team-card {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border-left: 5px solid #f1c40f;
            transition: all 0.3s ease;
        }

        .team-card.locked {
            border-left-color: #e74c3c;
            background: rgba(231,76,60,0.1);
        }

        .team-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .team-name-display {
            font-size: 1.2rem;
            font-weight: bold;
            color: #f1c40f;
        }

        .session-status {
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .status-locked {
            background: #e74c3c;
            color: white;
        }

        .status-available {
            background: #27ae60;
            color: white;
        }

        .prompt-section {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(15px);
            margin-bottom: 30px;
        }

        .prompt-item {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            border-left: 4px solid #9b59b6;
        }

        .prompt-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 15px;
        }

        .prompt-team {
            font-weight: bold;
            color: #f1c40f;
            font-size: 1.1rem;
        }

        .prompt-task {
            color: #9b59b6;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .broken-prompt {
            background: rgba(231,76,60,0.2);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 3px solid #e74c3c;
            font-style: italic;
        }

        .improved-prompt {
            background: rgba(39,174,96,0.2);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 3px solid #27ae60;
        }

        .score-input {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 8px 12px;
            color: white;
            width: 80px;
            text-align: center;
            margin: 0 10px;
        }

        .score-input:focus {
            outline: none;
            border-color: #f1c40f;
        }

        .save-score-btn {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            border: none;
            padding: 8px 15px;
            border-radius: 15px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .connection-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 10px;
            font-weight: bold;
            z-index: 1000;
        }

        .connected {
            background: #27ae60;
            color: white;
        }

        .disconnected {
            background: #e74c3c;
            color: white;
        }

        .current-round-display {
            text-align: center;
            background: linear-gradient(45deg, #9b59b6, #8e44ad);
            padding: 15px 30px;
            border-radius: 15px;
            margin-bottom: 25px;
            font-size: 1.3rem;
            font-weight: bold;
        }

        @media (max-width: 1200px) {
            .rounds-container {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .game-controls {
                flex-direction: column;
                align-items: center;
            }
            
            .round-control {
                width: 100%;
                max-width: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="connection-indicator" id="connectionIndicator">üîÑ Connecting...</div>
    
    <div class="container">
        <header class="header">
            <h1>üèÜ Admin Dashboard</h1>
            <p>UltraTech GENIUS BATTLE - 3-Round Management System</p>
        </header>

        <div class="current-round-display" id="currentRoundDisplay">
            üéÆ Current Status: Waiting to Start
            <div id="adminTimerContainer" style="margin-top: 10px; display: none;">
                <div style="font-size: 1.8rem; color: #f1c40f; position: relative;">
                    ‚è±Ô∏è Time Remaining: <span id="adminTimer">0:00</span>
                    <span style="font-size: 0.9rem; opacity: 0.7; margin-left: 10px;">üåê Server Synced</span>
                </div>
            </div>
        </div>

        <div class="game-controls">
            <div class="round-control" id="round1Control">
                <div class="round-title">üß† Round 1: Fundamentals</div>
                <div style="margin-bottom: 10px; font-size: 0.9rem;">10 Questions ‚Ä¢ 8 Minutes</div>
                <button class="control-btn start" onclick="startRound(1)" id="startRound1">Start Round 1</button>
                <button class="control-btn stop" onclick="stopRound()" id="stopRound1" disabled>Stop Round</button>
                <button class="control-btn reset" onclick="resetRound(1)">Reset Round 1</button>
            </div>
            
            <div class="round-control" id="round2Control">
                <div class="round-title">üéØ Round 2: Scenarios</div>
                <div style="margin-bottom: 10px; font-size: 0.9rem;">10 Questions ‚Ä¢ 12 Minutes</div>
                <button class="control-btn start" onclick="startRound(2)" id="startRound2">Start Round 2</button>
                <button class="control-btn stop" onclick="stopRound()" id="stopRound2" disabled>Stop Round</button>
                <button class="control-btn reset" onclick="resetRound(2)">Reset Round 2</button>
            </div>
            
            <div class="round-control" id="round3Control">
                <div class="round-title">‚úèÔ∏è Round 3: Prompts</div>
                <div style="margin-bottom: 10px; font-size: 0.9rem;">2 Tasks ‚Ä¢ 3 Minutes</div>
                <button class="control-btn start" onclick="startRound(3)" id="startRound3">Start Round 3</button>
                <button class="control-btn stop" onclick="stopRound()" id="stopRound3" disabled>Stop Round</button>
                <button class="control-btn reset" onclick="resetRound(3)">Reset Round 3</button>
            </div>
        </div>

        <div class="game-reset-section">
            <h3>üîß Session Management</h3>
            <div style="display: flex; gap: 15px; justify-content: center; margin-bottom: 20px; flex-wrap: wrap;">
                <button class="control-btn" style="background: linear-gradient(45deg, #e67e22, #f39c12);" onclick="forceUnlockAllSessions()">
                    üîì Force Unlock All Sessions
                </button>
            </div>
            
            <h3>üö® Danger Zone</h3>
            <div class="warning-text">
                ‚ö†Ô∏è This will reset EVERYTHING: all scores, prompts, and game state!
            </div>
            <button class="control-btn danger" onclick="resetEntireGame()">
                üîÑ RESET ENTIRE GAME
            </button>
        </div>

        <div class="stats-overview">
            <div class="stat-card">
                <div class="stat-number">10</div>
                <div class="stat-label">Total Teams</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="activeSessions">0</div>
                <div class="stat-label">Active Sessions</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="round1Complete">0</div>
                <div class="stat-label">Round 1 Complete</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="round2Complete">0</div>
                <div class="stat-label">Round 2 Complete</div>
            </div>
        </div>

        <div class="rounds-container">
            <div class="round-section">
                <h2>üèÜ Round 1 Leaderboard</h2>
                <div id="round1Leaderboard">
                    <div style="text-align: center; opacity: 0.6;">Round 1 not started yet</div>
                </div>
            </div>
            
            <div class="round-section">
                <h2>üèÜ Round 2 Leaderboard</h2>
                <div id="round2Leaderboard">
                    <div style="text-align: center; opacity: 0.6;">Round 2 not started yet</div>
                </div>
            </div>
        </div>

        <div class="prompt-section">
            <h2 style="color: #f1c40f; margin-bottom: 20px; text-align: center;">‚úèÔ∏è Round 3: Submitted Prompts</h2>
            <div id="promptsDisplay">
                <div style="text-align: center; opacity: 0.6;">No prompts submitted yet</div>
            </div>
        </div>

        <div class="round-section">
            <h2>üë• Team Session Status</h2>
            <div class="teams-grid" id="teamsGrid"></div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBXA54F8OQvEo5RZzokUIBFT5pOUlQk-TQ",
            authDomain: "ultratech-quiz-ai.firebaseapp.com",
            projectId: "ultratech-quiz-ai",
            storageBucket: "ultratech-quiz-ai.firebasestorage.app",
            messagingSenderId: "846386736581",
            appId: "1:846386736581:web:91446988c0fc8597f92fac"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        // Team Data
        const teamData = {
            1: {name: "Team RAM", fullName: "Rapid Action Minds"},
            2: {name: "Team GB", fullName: "Giggle Bytes"},
            3: {name: "Team WiFi", fullName: "We're fun inside"},
            4: {name: "Team AI", fullName: "Accelerated Innovators"},
            5: {name: "Team IP", fullName: "Infinite Pings"},
            6: {name: "Team WAF", fullName: "We are Fabulous"},
            7: {name: "Team TAG", fullName: "Think, Act, Grow"},
            8: {name: "Team SSO", fullName: "Smart Solutions only"},
            9: {name: "Team TB", fullName: "Tech Brigade"},
            10: {name: "Team MB", fullName: "Mega Buddies"}
        };

        let currentRound = 0;
        let teams = [];
        let prompts = [];

        // Initialize
        window.onload = function() {
            loadExistingGameState(); // Load existing state first
            loadTeamData();
            loadPrompts();
            startRealTimeListeners();
            updateConnectionStatus(true);
        };

        async function initializeGameState() {
            try {
                await db.collection('gameState').doc('current').set({
                    currentRound: 0,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
                
                updateRoundDisplay();
            } catch (error) {
                console.error('Error initializing game state:', error);
            }
        }

        async function startRound(round) {
            try {
                // Calculate round duration in milliseconds
                let roundDuration;
                if (round === 1) roundDuration = 8 * 60 * 1000; // 8 minutes
                else if (round === 2) roundDuration = 12 * 60 * 1000; // 12 minutes  
                else if (round === 3) roundDuration = 3 * 60 * 1000; // 3 minutes
                
                const startTime = new Date();
                const endTime = new Date(startTime.getTime() + roundDuration);
                
                // Update game state with timer info
                await db.collection('gameState').doc('current').update({
                    currentRound: round,
                    roundStartTime: firebase.firestore.Timestamp.fromDate(startTime),
                    roundEndTime: firebase.firestore.Timestamp.fromDate(endTime),
                    roundDuration: roundDuration,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                currentRound = round;
                updateRoundDisplay();
                updateControlButtons();
                startAdminTimer(roundDuration);
                
                console.log(`Round ${round} started at ${startTime.toISOString()}, ends at ${endTime.toISOString()}`);
                alert(`‚úÖ Round ${round} started for all teams!`);
                
            } catch (error) {
                console.error('Error starting round:', error);
                alert('Error starting round. Please try again.');
            }
        }

        let adminTimer = null;
        let adminTimeLeft = 0;

        function startAdminTimer(duration) {
            clearInterval(adminTimer);
            adminTimeLeft = Math.floor(duration / 1000);
            
            adminTimer = setInterval(() => {
                adminTimeLeft--;
                updateAdminTimerDisplay();
                
                if (adminTimeLeft <= 0) {
                    clearInterval(adminTimer);
                    handleAdminTimerEnd();
                }
            }, 1000);
        }

        function updateAdminTimerDisplay() {
            const timerElement = document.getElementById('adminTimer');
            if (timerElement) {
                const mins = Math.floor(adminTimeLeft / 60);
                const secs = adminTimeLeft % 60;
                timerElement.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                
                if (adminTimeLeft <= 60) {
                    timerElement.style.color = '#e74c3c';
                    timerElement.style.animation = 'pulse 1s infinite';
                } else {
                    timerElement.style.color = '#f1c40f';
                    timerElement.style.animation = 'none';
                }
            }
        }

        function handleAdminTimerEnd() {
            alert(`‚è∞ Round ${currentRound} time is up! Click "Stop Round" to end it.`);
        }

        async function forceUnlockAllSessions() {
            if (!confirm('üîì Force unlock ALL team sessions? This will allow new team members to join.')) {
                return;
            }
            
            try {
                const batch = db.batch();
                
                for (let i = 1; i <= 10; i++) {
                    const teamRef = db.collection('teams').doc(i.toString());
                    batch.update(teamRef, {
                        sessionLocked: false,
                        sessionTimeout: firebase.firestore.FieldValue.delete(),
                        lastActivity: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
                
                await batch.commit();
                alert('‚úÖ All team sessions have been force unlocked!');
                
                // Refresh data
                loadTeamData();
                
            } catch (error) {
                console.error('Error unlocking sessions:', error);
                alert('Error unlocking sessions. Please try again.');
            }
        }

        async function stopRound() {
            try {
                await db.collection('gameState').doc('current').update({
                    currentRound: currentRound + 10, // Mark as ended (11, 12, 13)
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                updateRoundDisplay();
                updateControlButtons();
                
            } catch (error) {
                console.error('Error stopping round:', error);
                alert('Error stopping round. Please try again.');
            }
        }

        async function resetRound(round) {
            if (!confirm(`‚ö†Ô∏è Are you sure you want to reset Round ${round}? This will delete all scores for this round!`)) {
                return;
            }

            try {
                const batch = db.batch();
                
                // Reset all team scores for this round
                for (let i = 1; i <= 10; i++) {
                    const teamRef = db.collection('teams').doc(i.toString());
                    
                    if (round === 1) {
                        batch.update(teamRef, {
                            'rounds.round1.score': 0,
                            'rounds.round1.completed': false,
                            'rounds.round1.answers': [],
                            lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    } else if (round === 2) {
                        batch.update(teamRef, {
                            'rounds.round2.score': 0,
                            'rounds.round2.completed': false,
                            'rounds.round2.answers': [],
                            lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    } else if (round === 3) {
                        batch.update(teamRef, {
                            'rounds.round3.manualScore': 0,
                            'rounds.round3.completed': false,
                            'rounds.round3.prompts': [],
                            lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                }
                
                // If resetting round 3, also clear prompts collection
                if (round === 3) {
                    const promptsSnapshot = await db.collectionGroup('round3').get();
                    promptsSnapshot.forEach(doc => {
                        batch.delete(doc.ref);
                    });
                    
                    // Also clear main prompts collection
                    for (let i = 1; i <= 10; i++) {
                        const promptRef = db.collection('prompts').doc(i.toString());
                        batch.delete(promptRef);
                    }
                }
                
                await batch.commit();
                alert(`‚úÖ Round ${round} has been reset successfully!`);
                
                // Refresh data
                loadTeamData();
                loadPrompts();
                
            } catch (error) {
                console.error('Error resetting round:', error);
                alert('Error resetting round. Please try again.');
            }
        }

        async function initializeGameState() {
            try {
                await db.collection('gameState').doc('current').set({
                    currentRound: 0,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
                
                updateRoundDisplay();
            } catch (error) {
                console.error('Error initializing game state:', error);
            }
        }

        async function resetEntireGame() {
            if (!confirm(`üö® DANGER: Reset ENTIRE GAME? This will:\n\n‚úó Delete ALL scores for ALL rounds\n‚úó Clear ALL submitted prompts\n‚úó Reset game state to beginning\n‚úó Unlock all team sessions\n‚úó Clear all saved states\n\nThis action CANNOT be undone!\n\nType "RESET" in the next prompt to confirm.`)) {
                return;
            }
            
            const confirmation = prompt('Type "RESET" to confirm complete game reset:');
            if (confirmation !== 'RESET') {
                alert('Game reset cancelled.');
                return;
            }

            try {
                const batch = db.batch();
                
                // Reset game state (clear timer fields too)
                const gameStateRef = db.collection('gameState').doc('current');
                batch.set(gameStateRef, {
                    currentRound: 0,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Reset all teams (clear saved states too)
                for (let i = 1; i <= 10; i++) {
                    const teamRef = db.collection('teams').doc(i.toString());
                    batch.set(teamRef, {
                        name: teamData[i].name,
                        fullName: teamData[i].fullName,
                        sessionLocked: false,
                        rounds: {
                            round1: { score: 0, completed: false, answers: [] },
                            round2: { score: 0, completed: false, answers: [] },
                            round3: { manualScore: 0, completed: false, prompts: [] }
                        },
                        lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
                
                await batch.commit();
                
                // Clear admin timer
                clearInterval(adminTimer);
                
                // Clear all prompts in separate operation
                try {
                    const promptsSnapshot = await db.collectionGroup('round3').get();
                    const promptBatch = db.batch();
                    
                    promptsSnapshot.forEach(doc => {
                        promptBatch.delete(doc.ref);
                    });
                    
                    // Also clear main prompts collection
                    for (let i = 1; i <= 10; i++) {
                        const promptRef = db.collection('prompts').doc(i.toString());
                        promptBatch.delete(promptRef);
                    }
                    
                    await promptBatch.commit();
                } catch (promptError) {
                    console.error('Error clearing prompts:', promptError);
                }
                
                alert('üéÆ ENTIRE GAME RESET SUCCESSFULLY!\n\n‚úÖ All scores cleared\n‚úÖ All prompts deleted\n‚úÖ Game state reset\n‚úÖ All sessions unlocked\n‚úÖ All saved states cleared');
                
                // Reset local state
                currentRound = 0;
                teams = [];
                prompts = [];
                
                // Refresh all data
                updateRoundDisplay();
                loadTeamData();
                loadPrompts();
                
            } catch (error) {
                console.error('Error resetting entire game:', error);
                alert('‚ùå Error resetting game. Please try again or refresh the page.');
            }
        }

        function updateRoundDisplay() {
            const display = document.getElementById('currentRoundDisplay');
            const timerContainer = document.getElementById('adminTimerContainer');
            const controls = document.querySelectorAll('.round-control');
            
            // Reset all controls
            controls.forEach(control => control.classList.remove('active'));
            
            if (currentRound === 0) {
                display.firstChild.textContent = 'üéÆ Current Status: Waiting to Start';
                timerContainer.style.display = 'none';
            } else if (currentRound >= 1 && currentRound <= 3) {
                display.firstChild.textContent = `üéØ Current Status: Round ${currentRound} Active`;
                document.getElementById(`round${currentRound}Control`).classList.add('active');
                timerContainer.style.display = 'block';
            } else if (currentRound >= 11 && currentRound <= 13) {
                const round = currentRound - 10;
                display.firstChild.textContent = `‚èπÔ∏è Current Status: Round ${round} Ended`;
                timerContainer.style.display = 'none';
            }
            
            updateControlButtons();
        }

        async function loadExistingGameState() {
            try {
                const gameDoc = await db.collection('gameState').doc('current').get();
                if (gameDoc.exists) {
                    const gameData = gameDoc.data();
                    currentRound = gameData.currentRound || 0;
                    
                    // If there's an active round with timer, restore it
                    if (currentRound >= 1 && currentRound <= 3 && gameData.roundEndTime) {
                        const now = new Date();
                        const endTime = gameData.roundEndTime.toDate();
                        const timeLeft = Math.floor((endTime - now) / 1000);
                        
                        if (timeLeft > 0) {
                            adminTimeLeft = timeLeft;
                            startAdminTimer(timeLeft * 1000);
                            console.log(`Restored timer for Round ${currentRound}: ${timeLeft} seconds remaining`);
                        } else {
                            console.log(`Round ${currentRound} timer already expired`);
                        }
                    }
                }
                updateRoundDisplay();
            } catch (error) {
                console.error('Error loading game state:', error);
            }
        }

        function updateControlButtons() {
            // Disable/enable appropriate buttons based on current round
            for (let i = 1; i <= 3; i++) {
                const startBtn = document.getElementById(`startRound${i}`);
                const stopBtn = document.getElementById(`stopRound${i}`);
                
                if (currentRound === i) {
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                } else {
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                }
            }
        }

        async function loadTeamData() {
            try {
                const snapshot = await db.collection('teams').get();
                teams = [];
                
                // Ensure all 10 teams exist
                for (let i = 1; i <= 10; i++) {
                    const teamDoc = snapshot.docs.find(doc => doc.id === i.toString());
                    if (teamDoc) {
                        teams.push({
                            id: teamDoc.id,
                            ...teamDoc.data(),
                            ...teamData[i]
                        });
                    } else {
                        teams.push({
                            id: i.toString(),
                            ...teamData[i],
                            sessionLocked: false,
                            rounds: {
                                round1: { score: 0, completed: false },
                                round2: { score: 0, completed: false },
                                round3: { manualScore: 0, completed: false }
                            }
                        });
                    }
                }
                
                updateDashboard();
                updateConnectionStatus(true);
                
            } catch (error) {
                console.error('Error loading team data:', error);
                updateConnectionStatus(false);
            }
        }

        async function loadPrompts() {
            try {
                const snapshot = await db.collectionGroup('round3').get();
                prompts = [];
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const teamId = doc.ref.parent.parent.id;
                    prompts.push({
                        teamId,
                        taskId: doc.id,
                        ...data,
                        teamName: teamData[teamId]?.name || `Team ${teamId}`
                    });
                });
                
                updatePromptsDisplay();
                
            } catch (error) {
                console.error('Error loading prompts:', error);
            }
        }

        function updateDashboard() {
            updateStatistics();
            updateLeaderboards();
            updateTeamsGrid();
        }

        function updateStatistics() {
            const activeSessions = teams.filter(team => team.sessionLocked).length;
            const round1Complete = teams.filter(team => team.rounds?.round1?.completed).length;
            const round2Complete = teams.filter(team => team.rounds?.round2?.completed).length;

            document.getElementById('activeSessions').textContent = activeSessions;
            document.getElementById('round1Complete').textContent = round1Complete;
            document.getElementById('round2Complete').textContent = round2Complete;
        }

        function updateLeaderboards() {
            updateRoundLeaderboard(1);
            updateRoundLeaderboard(2);
        }

        function updateRoundLeaderboard(round) {
            const container = document.getElementById(`round${round}Leaderboard`);
            const roundTeams = teams
                .filter(team => team.rounds?.[`round${round}`]?.score > 0 || team.rounds?.[`round${round}`]?.completed)
                .sort((a, b) => (b.rounds?.[`round${round}`]?.score || 0) - (a.rounds?.[`round${round}`]?.score || 0));

            if (roundTeams.length === 0) {
                container.innerHTML = `<div style="text-align: center; opacity: 0.6;">Round ${round} not started yet</div>`;
                return;
            }

            const leaderboardHTML = roundTeams.map((team, index) => {
                const rank = index + 1;
                let rankClass = '';
                if (rank === 1) rankClass = 'first';
                else if (rank === 2) rankClass = 'second';
                else if (rank === 3) rankClass = 'third';

                const score = team.rounds?.[`round${round}`]?.score || 0;
                const completed = team.rounds?.[`round${round}`]?.completed ? '‚úÖ' : '‚è≥';

                return `
                    <div class="leaderboard-item">
                        <div class="rank ${rankClass}">#${rank}</div>
                        <div class="team-info">
                            <div class="team-name">${team.name}</div>
                            <div class="team-details">${team.fullName} ${completed}</div>
                        </div>
                        <div class="score">${score}</div>
                    </div>
                `;
            }).join('');

            container.innerHTML = leaderboardHTML;
        }

        function updateTeamsGrid() {
            const container = document.getElementById('teamsGrid');
            
            const teamsHTML = teams.map(team => {
                const isLocked = team.sessionLocked || false;
                
                // Show live scores during active rounds, final scores otherwise
                let round1Score = team.rounds?.round1?.score || 0;
                let round2Score = team.rounds?.round2?.score || 0;
                const round3Score = team.rounds?.round3?.manualScore || 0;
                
                // Show live scores if round is active and not completed
                if (currentRound === 1 && !team.rounds?.round1?.completed && team.rounds?.round1?.liveScore !== undefined) {
                    round1Score = team.rounds.round1.liveScore;
                }
                if (currentRound === 2 && !team.rounds?.round2?.completed && team.rounds?.round2?.liveScore !== undefined) {
                    round2Score = team.rounds.round2.liveScore;
                }

                return `
                    <div class="team-card ${isLocked ? 'locked' : ''}">
                        <div class="team-header">
                            <div class="team-name-display">${team.name}</div>
                            <div class="session-status ${isLocked ? 'status-locked' : 'status-available'}">
                                ${isLocked ? 'üîí Active' : '‚úÖ Available'}
                            </div>
                        </div>
                        <div style="font-size: 0.9rem; color: #bdc3c7; margin-bottom: 10px;">
                            ${team.fullName}
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; text-align: center; margin-bottom: 10px;">
                            <div>
                                <div style="font-size: 0.8rem; opacity: 0.7;">
                                    Round 1 ${currentRound === 1 && !team.rounds?.round1?.completed ? 'üî¥ LIVE' : ''}
                                </div>
                                <div style="font-size: 1.2rem; font-weight: bold; color: #27ae60;">${round1Score}</div>
                            </div>
                            <div>
                                <div style="font-size: 0.8rem; opacity: 0.7;">
                                    Round 2 ${currentRound === 2 && !team.rounds?.round2?.completed ? 'üî¥ LIVE' : ''}
                                </div>
                                <div style="font-size: 1.2rem; font-weight: bold; color: #3498db;">${round2Score}</div>
                            </div>
                            <div>
                                <div style="font-size: 0.8rem; opacity: 0.7;">Round 3</div>
                                <div style="font-size: 1.2rem; font-weight: bold; color: #9b59b6;">${round3Score}</div>
                            </div>
                        </div>
                        ${isLocked ? `
                            <button class="control-btn" style="font-size: 0.8rem; padding: 5px 10px;" 
                                    onclick="forceUnlockTeam('${team.id}')">
                                üîì Force Unlock
                            </button>
                        ` : ''}
                    </div>
                `;
            }).join('');

            container.innerHTML = teamsHTML;
        }

        async function forceUnlockTeam(teamId) {
            if (!confirm(`üîì Force unlock ${teamData[teamId].name}?`)) {
                return;
            }
            
            try {
                await db.collection('teams').doc(teamId).update({
                    sessionLocked: false,
                    sessionTimeout: firebase.firestore.FieldValue.delete()
                });
                
                alert(`‚úÖ ${teamData[teamId].name} has been force unlocked!`);
                loadTeamData();
                
            } catch (error) {
                console.error('Error unlocking team:', error);
                alert('Error unlocking team. Please try again.');
            }
        }

        function updatePromptsDisplay() {
            const container = document.getElementById('promptsDisplay');
            
            if (prompts.length === 0) {
                container.innerHTML = '<div style="text-align: center; opacity: 0.6;">No prompts submitted yet</div>';
                return;
            }

            // Group prompts by team
            const promptsByTeam = {};
            prompts.forEach(prompt => {
                if (!promptsByTeam[prompt.teamId]) {
                    promptsByTeam[prompt.teamId] = [];
                }
                promptsByTeam[prompt.teamId].push(prompt);
            });

            const promptsHTML = Object.keys(promptsByTeam).map(teamId => {
                const teamPrompts = promptsByTeam[teamId];
                const teamName = teamData[teamId]?.name || `Team ${teamId}`;
                
                const promptsForTeam = teamPrompts.map(prompt => `
                    <div style="margin: 15px 0; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px;">
                        <div class="prompt-task">üìù ${prompt.taskTitle}</div>
                        <div class="broken-prompt">
                            <strong>‚ùå Original:</strong> "${prompt.brokenPrompt}"
                        </div>
                        <div class="improved-prompt">
                            <strong>‚úÖ Improved:</strong> ${prompt.improvedPrompt}
                        </div>
                        <div style="margin-top: 10px; display: flex; align-items: center; gap: 10px;">
                            <label style="font-weight: bold;">Manual Score:</label>
                            <input type="number" class="score-input" min="0" max="10" 
                                   value="${teams.find(t => t.id === teamId)?.rounds?.round3?.manualScore || 0}"
                                   onchange="updateManualScore('${teamId}', this.value)">
                            <span style="opacity: 0.7;">/10</span>
                        </div>
                    </div>
                `).join('');
                
                return `
                    <div class="prompt-item">
                        <div class="prompt-header">
                            <div class="prompt-team">üèÜ ${teamName}</div>
                        </div>
                        ${promptsForTeam}
                    </div>
                `;
            }).join('');

            container.innerHTML = promptsHTML;
        }

        async function updateManualScore(teamId, score) {
            try {
                await db.collection('teams').doc(teamId).update({
                    'rounds.round3.manualScore': parseInt(score) || 0,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Update local teams data
                const team = teams.find(t => t.id === teamId);
                if (team) {
                    if (!team.rounds) team.rounds = {};
                    if (!team.rounds.round3) team.rounds.round3 = {};
                    team.rounds.round3.manualScore = parseInt(score) || 0;
                }
                
                updateTeamsGrid();
                
            } catch (error) {
                console.error('Error updating manual score:', error);
                alert('Error updating score. Please try again.');
            }
        }

        function startRealTimeListeners() {
            // Listen for game state changes
            db.collection('gameState').doc('current').onSnapshot((doc) => {
                if (doc.exists) {
                    const data = doc.data();
                    const newRound = data.currentRound || 0;
                    
                    // Only update if round actually changed (avoid timer conflicts)
                    if (newRound !== currentRound) {
                        currentRound = newRound;
                        updateRoundDisplay();
                        
                        // If there's an active timer, sync with it
                        if (newRound >= 1 && newRound <= 3 && data.roundEndTime) {
                            const now = new Date();
                            const endTime = data.roundEndTime.toDate();
                            const timeLeft = Math.floor((endTime - now) / 1000);
                            
                            if (timeLeft > 0) {
                                adminTimeLeft = timeLeft;
                                startAdminTimer(timeLeft * 1000);
                                console.log(`Synced admin timer: ${timeLeft} seconds remaining`);
                            }
                        }
                    }
                }
            });

            // Listen for team data changes
            db.collection('teams').onSnapshot(() => {
                loadTeamData();
            });

            // Listen for prompt submissions
            db.collectionGroup('round3').onSnapshot(() => {
                loadPrompts();
            });
        }

        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('connectionIndicator');
            if (connected) {
                indicator.textContent = '‚úÖ Connected';
                indicator.className = 'connection-indicator connected';
            } else {
                indicator.textContent = '‚ùå Connection Error';
                indicator.className = 'connection-indicator disconnected';
            }
        }
    </script>
</body>
</html>
